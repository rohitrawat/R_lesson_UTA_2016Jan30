---
title: "Lesson"
author: "Rohit Rawat"
date: "January 24, 2016"
output: pdf_document
---

```{r, echo=FALSE, message=FALSE}
require('knitr')
opts_chunk$set(results='hide')
```

# Outline

We have covered basic R usage:

- Reading data files
- Creating and manipulating variables
- Data type
- Calling built-int functions

Now we will cover:

- What are scripts and their use
- Where to write scripts in RStudio
- `source`ing a script, setting the working directory, and file paths
- Writing functions
- Scope issues in functions, Missing arguments
- Calling R scripts from the command line

# Writing scripts

Just like we learned to use shell commands like `grep`, `sort`, and `wc`, and then later learned how to write shell scripts.

Instead of writing individual statements on the command line like

```{r}
dataDir <- 'data'
dataFile <- 'gapminder-FiveYearData.csv'
fileName <- file.path(dataDir, dataFile)
```

```{r}
gapminder <- read.csv(fileName)
View(gapminder)
```

```{r}
startYear <- min(gapminder$year)
```

```{r}
endYear <- max(gapminder$year)
```

```{r}
paste('Data is from years', startYear, 'to', endYear)
```

We can paste all of these commands into a single file to write a script which is

- for ease in recall
- repetition
- properly commented code 

R scripts have the extension `.R`.

## Where to write scripts in RStudio

In the default layout, RStudio has a text editor in the upper left corner.

```{r}

# This script reads the gapminder data and prints the range of years it contains data for.

# read the file
dataDir <- 'data'
dataFile <- 'gapminder-FiveYearData.csv'
fileName <- file.path(dataDir, dataFile)
gapminder <- read.csv(fileName)

# find the minimum and maximum values in the 'year' column of the gapminder data
startYear <- min(gapminder$year)
endYear <- max(gapminder$year)

# Print the result as a message
print(paste('Data is from years', startYear, 'to', endYear))

```

## Advantages to using the RStudio editor

- Syntax highlighting
- Automatic code indentation
- Variable name completion with [tab] (like bash)
- Bracket pairing

# Sourcing a script, setting the working directory, and file paths

Scripts are executed using the `source()` function

`source(filename)`

You would normally use the `setwd()` command to change the working directory to where the script is stored and then call `source()`.

```{r}
setwd('~/Dropbox/Carpentry/R_lesson/gapminder')
source('script.R')
```

You can also press the button, which launches your script irrespective of the working directory. Although this may lead to problems if you are sourcing other scripts or loading files using a relative path. You can use the menu option Session -> Set Working Directory -> To source file location to set the current working directory to where your R code is.

## Challenge

Write and run your own script that will

- Set `x` to 25
- Set `y` to 15
- Calculate the sum and store it in a variable `z`
- print `z`

------------------------------------------

# Creating Functions

If we only had one data set to analyze, it would probably be faster to load the file into a spreadsheet and use that to plot some simple statistics. 
But we have twelve files to check, and may have more in future. In this lesson, we'll learn how to write a function so that we can repeat several operations with a single command.

## Objectives

* Define a function that takes parameters.
* Return a value from a function.
* Test and debug a function.
* Explain what a call stack is, and trace changes to the call stack as functions are called.
* Set default values for function parameters.
* Explain why we should divide programs into small, single-purpose functions.
* Defining a Function

Let's start by defining a function `fahr_to_kelvin` that converts temperatures from Fahrenheit to Kelvin:

```{r}
temp <- NA
fahr_to_kelvin <- function(temp) {
    kelvin <- ((temp - 32) * (5/9)) + 273.15
	kelvin
}
```

The definition opens with the name of your new function, which is followed by the call to make it a `function` and a parenthesized list of parameter names. You can have as many input parameters as you would like (but too many might be bad style). The body, or implementation, is surrounded by curly braces `{ }`. In many languages, the body of the function - the statements that are executed when it runs - must be indented, typically using 4 spaces. While this is not a mandatory requirement in R coding, we strongly recommend you to adopt this as good practice.

When we call the function, the values we pass to it are assigned to those variables so that we can use them inside the function. The last line within the function is what R will evaluate as a returning value. Remember that the last line has to be a command that will print to the screen, and not an object definition, otherwise the function will return nothing - it will work, but will provide no output. For example, let's try running our function. Calling our own function is no different from calling any other function:

```{r}
fahr_to_kelvin(32)
paste('boiling point of water:', fahr_to_kelvin(212))
```

We've successfully called the function that we defined, and we have access to the value that we returned.

## Composing Functions

Now that we've seen how to turn Fahrenheit into Kelvin, it's easy to turn Kelvin into Celsius:

```{r}
kelvin_to_celsius <- function(temp) {
    Celsius <- temp - 273.15
	Celsius
}

paste('absolute zero in Celsius:', kelvin_to_celsius(0))
```

What about converting Fahrenheit to Celsius? We could write out the formula, but we don't need to. Instead, we can compose the two functions we have already created:

```{r}
fahr_to_celsius <- function(temp) {
	temp_k <- fahr_to_kelvin(temp)
	result <- kelvin_to_celsius(temp_k)
    result
}

paste('freezing point of water in Celsius:', fahr_to_celsius(32.0))
```

This is our first taste of how larger programs are built: we define basic operations, then combine them in ever-large chunks to get the effect we want. 
Real-life functions will usually be larger than the ones shown here—typically half a dozen to a few dozen lines—but they shouldn't ever be much longer than that, or the next person who reads it won't be able to understand what's going on. __Modular programming__


### Challenges

As we've seen in our print statements, we can use `paste` to concatenate strings, `paste(a, b, sep = "")` is `ab`. __Note__: the `sep` can be an important value to define! What is the default? What can `sep` be?

1. Write a function called `fence` that takes two parameters called `original` and `wrapper` and returns a new string that has the `wrapper` character at the beginning and end of the `original`:

```{r, echo=FALSE}
fence  <-  function(original, wrapper) {
    paste(wrapper, original, wrapper, sep="")
}
```
```
fence('name', '*')
*name*
```

__BREAK__

## Explaining the R Environments

Let's take a closer look at wha+t happens when we call `fahr_to_celsius(32)`. To make things clearer, we'll start by putting the initial value 32 in a variable and store the final result in one as well:

```{r}
original <- 32.0
final    <- fahr_to_celsius(original)
```

_Discuss and draw a diagram showing what memory looks like after the first line has been executed. Point to the environment_

When we call `fahr_to_celsius`, R doesn't create the variable temp right away. Instead, it creates a new environment, local to the function, to keep track of the variables defined by `fahr_to_kelvin`. Initially, the environment only holds the value of temp:

Your function has its own environment where variables local to that function are stored (`temp` in this case). Since R is lexically scoped that means that the function's environment has a parent environment which is defined by where the function is defined, the global environment in this case (if it were defined inside of another function then the parent environment would be the env for that function).

When we call `fahr_to_kelvin` inside `fahr_to_celsius`, R creates another local environment to hold `fahr_to_kelvin` variables:

When you call `fahr_to_celsius` and it calls `fahr_to_kelvin` then `fahr_to_kelvin` tries to find the variable `temp`, it first looks in its own environment, but if it does not find it there, then looks in its parent environment which is the global env. 

It does this because there are now two variables in play called `temp`: the parameter to `fahr_to_celsius`, and the parameter to `fahr_to_kelvin`. 
Having two variables with the same name in the same part of the program would be ambiguous, so R (and every other modern programming language) creates a new environment for each function call to keep that function's variables separate from those defined by other functions.

When the call to `fahr_to_kelvi`n returns a value, R throws away `fahr_to_kelvin` stack frame and creates a new variable in the stack frame for `fahr_to_celsius` to hold the temperature in Kelvin:

It then calls `kelvin_to_celsius`, which means it creates an environment to hold that function's variables:

Once again, R throws away that stack frame when `kelvin_to_celsius` is done and creates the variable result in the environment for `fahr_to_celsius`:

Finally, when `fahr_to_celsius` is done, R throws away its environment and puts its result in a new variable called final that lives in the `global environment` we started with:

So we need to be really careful when writing functions that we define the correct inputs. For example, if we had not written our function correctly, if `fahr_to_kelvin` input was `temp2`, then instead of using the `temp` input to the function, it would search the global environment for something else that could be defined. In this case, we would get an answer, but it would be the wrong one. If we had correctly assigned it as `temp`, the value would have been correctly carried through within the function's environment.

The summary of this is that the parent environment (global is the parent of `fahr_to_celsius`, `fahr_to_celsius` is the parent to `fahr_to_kelvin`) is the environment where a function was defined (lexical scoping), the parent frame is the frame/environment from which the function was called (simulated dynamic scoping).

This final environment/stack frame is always there; it holds the variables we defined outside the functions in our code. What it doesn't hold is the variables that were in the various stack frames. If we try to get the value of temp after our functions have finished running, R tells us that there's no such thing:

```{r}
paste('final value of temp after all function calls:', temp)
```

Why go to all this trouble? Well, here's a function called `range` that calculates the difference between the mininum and maximum values in an array:

```{r}
help(range) #or ?range

numbers  <-  1:100
range(numbers)
```

We might very well use a variable with the same name to hold data:

```{r}
numRange  <-  range(numbers)
```

Same for the celsius function: 

```{r}
hot = 29
fahr_to_celsius(hot)
```

We don't expect `range` to have the value 20.0 after this function call, so the name diff cannot refer to the same thing inside span as it does in the main body of our program. And yes, we could probably choose a different name than diff in our main program in this case, but we don't want to have to read every line of function that we use to see what variable names its functions use before calling any of those functions, just in case they change the values of our variables.

The big idea here is __encapsulation__, and it's the key to writing correct, comprehensible programs. A function's job is to turn several operations into one so that we can think about a single function call instead of a dozen or a hundred statements each time we want to do something. That only works if functions don't interfere with each other; if they do, we have to pay attention to the details once again, which quickly overloads our short-term memory.


## Defining Defaults

We have passed parameters to functions in two ways: directly, as in `dim(matrixdata)`, and by name, as in `matrix(data = 0, nrow = 2, ncol = 2)`. In fact, we can pass the filename to loadtxt without the `nrow=`:

```{r}
matrix(0,2,2)
```

To understand what's going on, and make our own functions easier to use, let's re-define our center function like this:

```{r}
center <- function(data, desired=0){
    #return a new matrix containing the original data centered around the desired value.
    new <- (data - mean(data)) + desired
    new
}
```

The key change is that the second parameter is now written `desired=0` instead of just `desired`. If we call the function with two arguments, it works as it did before:

```{r}
test_data <- matrix(0,2,2)
center(test_data, 3)
```

But we can also now call it with just one parameter, in which case desired is automatically assigned the default value of 0.0:

```{r}
more_data <- matrix(0, 2, 2) + 5
more_data
center(more_data)
```

This is handy: if we usually want a function to work one way, but occasionally need it to do something else, we can allow people to pass a parameter when they need to but provide a default to make the normal case easier. The example below shows how R matches values to parameters:

```{r}
display <- function(a=1, b=2, c=3) {
	paste('a:', a, 'b:', b, 'c:', c)
}
		
paste('no parameters:', display())
paste('one parameter:', display(55))
paste('two parameters:', display(55, 66))
paste('three parameters:', display (55, 66, 77))
```

As this example shows, parameters are matched up from left to right, and any that haven't been given a value explicitly get their default value. We can override this behavior by naming the value as we pass it in:

```{r}
paste('only setting the value of c', display(c=77))
```

With that in hand, let's look at the help for `read.csv`:

```{r}
help(read.csv) #or ?read.csv
```

_walk through the help file, point out important items. How to read the defaults, how to know what you need to specify. Definitions and examples..._

There's a lot of information here, but the most important part is the first couple of lines:

```{r, eval=FALSE}
read.csv(file, header = TRUE, sep = ",", quote = "\"",
         dec = ".", fill = TRUE, comment.char = "", ...)
```

This tells us that `read.csv` has one parameter called file that doesn't have a default value, and eight others that do. If we call the function like this:

```{r}
read.csv(fileName)
```

then the filename is assigned to name (which is what we want), but the delimiter string ',' is assigned to `header` rather than `sep`, because `header` is the second parameter in the list. That's why we don't have to provide `file=` for the filename, but do have to provide `sep=` for the second parameter.

### Challenges

Write a function `getAverageGdpPerCapita` that takes the name of a country, then computes the averaged GDP per capita.

```{r}
allCountryNames <- levels(gapminder$country)
unscPermanentMembers <- c('China', 'France', 'Russia', 'United Kingdom', 'United States')
southAmericanCountries <- c('Argentina', 'Bolivia', 'Brazil', 'Chile', 'Colombia', 'Ecuador', 'Paraguay', 'Peru', 'Uruguay', 'Venezuela')

getAverageGdpPerCapita <- function(country) {
  # extract gdpPercap from the gapminder data four the specified country.
  
  selectedCountryData <- gapminder[gapminder$country == country, 'gdpPercap']
  
  mean(selectedCountryData)
}

gdpUSA <- getAverageGdpPerCapita('United States')
gdpCanada <- getAverageGdpPerCapita('Canada')
gdpMexico <- getAverageGdpPerCapita('Mexico')

averagedGdpUnscPermanentMembers <- sapply(unscPermanentMembers, getAverageGdpPerCapita)
barplot(averagedGdpUnscPermanentMembers)

print(averagedGdpUnscPermanentMembers)
```


Key Points
===============
* Define a function using `function` name(...params...).
* The body of a function should be indented.
* Call a function using name(...values...).
* Numbers are stored as integers or floating-point numbers.
* Each time a function is called, a new stack frame is created on the call stack to hold its parameters and local variables.
* R looks for variables in the current environment before looking for them at the top level.
* Use help(thing) to view help for something.
* Put docstrings in functions to provide help for that function.
* Annotate your code!
* Specify default values for parameters when defining a function using name=value in the parameter list.
* Parameters can be passed by matching based on name, by position, or by omitting them (in which case the default value is used).


------------------------------------------------

# Calling R scripts from the command line

Just like we can call other scripts and functions from our R programs, we can call an R script from the command line. We use the Rscript program to do this.

`Rscript filename.R`

If Rscript is not on your system's path, you can invoke Rscript using it's full path name.

Try it out:

script.R:
```
print('This is a simple R script')
```

On the command line:
```
Rscript filename.R
```

Even if you do your data analysis in a different programming language, you can still use R's plotting capabilities (which we will learn more about in the afternoon session). We will write a script that will produce a barplot from a given datafile. In the previous example, script.R prints a fixed message and has no way of getting any information from the shell. Rscript allows you to send arguments to the R script by specifying them after the file name:

```
Rscript filename.R argument_1 argument_2 ...
```

These arguments can be accesed from within the R script by using the `commandArgs()` function. By default the list will include the name of the R executable, the script file name, and several switches. Using `commandArgs(FALSE)` only presents us with the arguments starting from `argument_1` onwards.

Updated script.R
```
countyList <- commandArgs(TRUE)

dataDir <- 'data'
dataFile <- 'gapminder-FiveYearData.csv'
fileName <- file.path(dataDir, dataFile)
gapminder <- read.csv(fileName)

getAverageGdpPerCapita <- function(country) {
  # extract gdpPercap from the gapminder data four the specified country.
  
  selectedCountryData <- gapminder[gapminder$country == country, 'gdpPercap']
  
  mean(selectedCountryData)
}

averagedGdp <- sapply(countyList, getAverageGdpPerCapita)
barplot(averagedGdp)

print(averagedGdp)
```

We now write a shell script that is going to call this method on a list of countries

```
countries="Canada Belgium"
Rscript cmdScript.R $countries
```

The generated plots are saved in PDF format in the file Rplots.pdf.
